<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Fluency Flow ‚Äì Movie Mode</title>

    <style>
      :root {
        --bg: #0b0f14;
        --panel: #121823;
        --text: #e6edf3;
        --muted: #9aa4b2;
        --accent: #5ea2ff;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      }

      header {
        background: var(--panel);
        padding: 14px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 10px;
      }

      select,
      input,
      button {
        background: #1a2230;
        color: var(--text);
        border: 1px solid #2b3545;
        border-radius: 6px;
        padding: 8px;
        font-size: 14px;
      }

      button {
        cursor: pointer;
      }

      button:hover {
        border-color: var(--accent);
      }

      main {
        height: calc(100vh - 120px);
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
      }

      .card {
        max-width: 800px;
        padding: 40px;
      }

      .kanji {
        font-size: 64px;
        margin-bottom: 12px;
      }

      .furigana {
        font-size: 28px;
        color: var(--muted);
        margin-bottom: 24px;
      }

        .romaji {
          font-size: 22px;
          color: var(--muted);
          margin-bottom: 18px;
          font-family: 'Segoe UI', Arial, sans-serif;
        }
        .romaji.hidden {
          display: none;
        }

      .meaning {
        font-size: 24px;
        line-height: 1.4;
      }

      footer {
        background: var(--panel);
        padding: 12px;
        display: flex;
        justify-content: center;
        gap: 12px;
      }

      .hidden {
        display: none;
      }

      .progress-indicator {
        position: absolute;
        top: 12px;
        right: 12px;
        font-size: 14px;
        color: var(--muted);
        background: rgba(0, 0, 0, 0.3);
        padding: 8px 12px;
        border-radius: 6px;
      }

      .summary-screen {
        background: var(--panel);
        padding: 40px;
        border-radius: 12px;
        max-width: 700px;
      }

      .summary-screen h2 {
        margin-top: 0;
        font-size: 32px;
        margin-bottom: 24px;
      }

      .summary-stat {
        display: flex;
        justify-content: space-between;
        padding: 12px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .summary-stat:last-child {
        border-bottom: none;
      }

      .summary-label {
        color: var(--muted);
      }

      .summary-value {
        font-weight: bold;
        color: var(--accent);
      }

      .summary-breakdown {
        margin-top: 24px;
        padding: 16px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 8px;
      }

      /* Hide number input spinners for interval control */
      input[type=number]::-webkit-outer-spin-button,
      input[type=number]::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type=number] {
          appearance: textfield;
          -moz-appearance: textfield; /* Firefox */
      }

      /* Responsive rules */
      @media (max-width: 900px) {
        header { padding: 10px; }
        .card { padding: 28px; max-width: 720px; }
        .kanji { font-size: clamp(40px, 14vw, 64px); }
        .furigana { font-size: clamp(16px, 6vw, 26px); }
        .meaning { font-size: clamp(14px, 4.5vw, 22px); }
        .summary-screen { padding: 20px; max-width: 92vw; }
        .summary-stat { flex-direction: column; gap: 6px; }
        .summary-label { font-size: 13px; }
        .summary-value { font-size: 16px; }
        .summary-buttons { flex-direction: column; }
        .summary-buttons button { width: 100%; }
        .progress-indicator { top: 8px; right: 8px; font-size: 13px; }
      }

      @media (max-width: 480px) {
        .card { padding: 20px; }
        .kanji { font-size: clamp(32px, 18vw, 56px); }
        .furigana { font-size: clamp(14px, 7vw, 22px); }
        .meaning { font-size: clamp(13px, 5vw, 20px); }
        header { gap: 8px; }
        select, input, button { padding: 6px 8px; font-size: 13px; }
      }

      .breakdown-item {
        padding: 8px 0;
        display: flex;
        justify-content: space-between;
      }

      .summary-buttons {
        display: flex;
        gap: 12px;
        margin-top: 24px;
      }

      .summary-buttons button {
        flex: 1;
        padding: 12px;
        font-size: 16px;
        font-weight: bold;
      }
    </style>
  </head>

  <body>
    <header>
      <div
        style="
          display: flex;
          gap: 12px;
          align-items: center;
          width: 100%;
          flex-wrap: wrap;
        "
      >
        <a
          href="index.html"
          style="
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #2b3545;
            background: #1a2230;
            color: var(--text);
            text-decoration: none;
            font-weight: bold;
            font-size: 13px;
            cursor: pointer;
          "
          title="Return to Library"
        >
          ‚Üê Library
        </a>

        <select id="knownness">
          <option value="all">All Words</option>
          <option value="wellKnown">Well Known</option>
          <option value="known">Known</option>
          <option value="exposed">Exposed</option>
          <option value="unknown">Unknown</option>
        </select>

        <select id="levelSelect">
          <optgroup label="Levels (100 words each)">
            <option value="1">Level 1</option>
            <option value="2">Level 2</option>
            <option value="3">Level 3</option>
            <option value="4">Level 4</option>
            <option value="5">Level 5</option>
            <option value="6">Level 6</option>
            <option value="7">Level 7</option>
            <option value="8">Level 8</option>
            <option value="9">Level 9</option>
            <option value="10">Level 10</option>
            <option value="11">Level 11</option>
            <option value="12">Level 12</option>
            <option value="13">Level 13</option>
            <option value="14">Level 14</option>
            <option value="15">Level 15</option>
            <option value="16">Level 16</option>
            <option value="17">Level 17</option>
            <option value="18">Level 18</option>
            <option value="19">Level 19</option>
            <option value="20">Level 20</option>
            <option value="21">Level 21</option>
            <option value="22">Level 22</option>
            <option value="23">Level 23</option>
            <option value="24">Level 24</option>
            <option value="25">Level 25</option>
            <option value="26">Level 26</option>
            <option value="27">Level 27</option>
            <option value="28">Level 28</option>
            <option value="29">Level 29</option>
            <option value="30">Level 30</option>
            <option value="31">Level 31</option>
            <option value="32">Level 32</option>
            <option value="33">Level 33</option>
            <option value="34">Level 34</option>
            <option value="35">Level 35</option>
            <option value="36">Level 36</option>
            <option value="37">Level 37</option>
            <option value="38">Level 38</option>
            <option value="39">Level 39</option>
            <option value="40">Level 40</option>
            <option value="41">Level 41</option>
            <option value="42">Level 42</option>
            <option value="43">Level 43</option>
            <option value="44">Level 44</option>
            <option value="45">Level 45</option>
            <option value="46">Level 46</option>
            <option value="47">Level 47</option>
            <option value="48">Level 48</option>
            <option value="49">Level 49</option>
            <option value="50">Level 50</option>
            <option value="51">Level 51</option>
            <option value="52">Level 52</option>
            <option value="53">Level 53</option>
            <option value="54">Level 54</option>
            <option value="55">Level 55</option>
            <option value="56">Level 56</option>
            <option value="57">Level 57</option>
            <option value="58">Level 58</option>
            <option value="59">Level 59</option>
            <option value="60">Level 60</option>
            <option value="61">Level 61</option>
            <option value="62">Level 62</option>
            <option value="63">Level 63</option>
            <option value="64">Level 64</option>
            <option value="65">Level 65</option>
            <option value="66">Level 66</option>
            <option value="67">Level 67</option>
            <option value="68">Level 68</option>
            <option value="69">Level 69</option>
            <option value="70">Level 70</option>
            <option value="71">Level 71</option>
            <option value="72">Level 72</option>
            <option value="73">Level 73</option>
            <option value="74">Level 74</option>
            <option value="75">Level 75</option>
            <option value="76">Level 76</option>
            <option value="77">Level 77</option>
            <option value="78">Level 78</option>
            <option value="79">Level 79</option>
            <option value="80">Level 80</option>
            <option value="81">Level 81</option>
          </optgroup>
          <optgroup label="JLPT Levels">
            <option value="jlpt-N1">JLPT N1</option>
            <option value="jlpt-N2">JLPT N2</option>
            <option value="jlpt-N3">JLPT N3</option>
            <option value="jlpt-N4">JLPT N4</option>
            <option value="jlpt-N5">JLPT N5</option>
          </optgroup>
            <option value="all">All Levels</option>
        </select>

        <input id="interval" type="number" min="0.5" step="0.1" value="3.6" title="words per second" />
          <label style="display: flex; align-items: center; gap: 6px; font-size: 14px;">
            <input type="checkbox" id="showRomaji" checked style="margin-right: 6px;" /> Show Romaji
          </label>
      </div>
    </header>

    <main>
      <div class="card" id="flowCard">
        <div class="progress-indicator" id="progressIndicator"></div>
        <div class="kanji" id="kanji">‚Äî</div>
        <div class="furigana" id="furigana"></div>
          <div class="romaji" id="romaji"></div>
        <div class="meaning" id="meaning">Press Play</div>
      </div>

      <div class="summary-screen hidden" id="summaryScreen">
        <h2>üé¨ MovieFlow Complete</h2>
        <div class="summary-stat">
          <span class="summary-label">Words Shown</span>
          <span class="summary-value" id="summaryWords">0</span>
        </div>
        <div class="summary-stat">
          <span class="summary-label">Total Time</span>
          <span class="summary-value" id="summaryTime">0m 0s</span>
        </div>
        <div class="summary-stat">
          <span class="summary-label">Words Per Minute</span>
          <span class="summary-value" id="summaryWPM">0</span>
        </div>

        <div class="summary-stat">
          <span class="summary-label">Extra-long Cards</span>
          <span class="summary-value" id="summaryLong">0</span>
        </div>

        <div class="summary-breakdown">
          <div
            style="color: var(--muted); margin-bottom: 12px; font-weight: bold"
          >
            Exposure Breakdown
          </div>
          <div class="breakdown-item">
            <span>All Words</span>
            <span id="breakdownAll">0</span>
          </div>
          <div class="breakdown-item">
            <span id="breakdownFamLabel">Unknown</span>
            <span id="breakdownFam">0</span>
          </div>
          <div class="breakdown-item">
            <span id="breakdownJLPTLabel">N5</span>
            <span id="breakdownJLPT">0</span>
          </div>
          <div class="breakdown-item">
            <span id="breakdownJLPTSubLabel">N5 Unknown</span>
            <span id="breakdownJLPTSub">0</span>
          </div>
        </div>

        <div class="summary-buttons">
          <button
            id="playNext"
            style="background: linear-gradient(135deg, #3a3f51, #1f2230)"
          >
            ‚ñ∂ Play Next Recommended
          </button>
          <button id="backToMenu">‚úì Okay</button>
        </div>
      </div>
    </main>

    <!-- loading overlay removed; parser now uses single-pass CSV parser for speed -->

    <footer>
      <button id="play">‚ñ∂ Play</button>
      <button id="pause">‚è∏ Pause</button>
    </footer>

    <script>
      // Storage keys (must match script.js)
      const LS_PROGRESS = "vocabProgress";
      const LS_DAILY = "vocabProgressDaily";
      const LS_HIGHEST = "vocabHighest";
      const LS_MOVIEFLOW = "movieflowExposure";
      const LS_MOVIEFLOW_DAILY = "movieflowDaily";

      let vocab = [];
      let filtered = [];
      let index = 0;
      let timer = null;
      // Per-card timing settings
      const LENGTH_MULTIPLIER = 1.9;
      const LENGTH_THRESHOLDS = { kanji: 6, furigana: 12, meaning: 32 };
      let flowStartTime = null;
      let flowEndTime = null;
      let flowLongCount = 0;
      let flowWordCount = 0;
      let progressMap = {};
      let movieflowMap = {};
      let movieflowDailyMap = {};

      // Loading overlay removed; keep small helper placeholders
      function showLoading() {}
      function hideLoading() {}
      function updateLoadingProgress() {}

      function loadCaches() {
        try {
          progressMap = JSON.parse(localStorage.getItem(LS_PROGRESS) || "{}");
        } catch (e) {
          progressMap = {};
        }
        try {
          movieflowMap = JSON.parse(localStorage.getItem(LS_MOVIEFLOW) || "{}");
        } catch (e) {
          movieflowMap = {};
        }
        try {
          movieflowDailyMap = JSON.parse(
            localStorage.getItem(LS_MOVIEFLOW_DAILY) || "{}"
          );
        } catch (e) {
          movieflowDailyMap = {};
        }
      }

      function addDailyProgress(delta) {
        if (!delta || delta <= 0) return;
        try {
          const dlog = JSON.parse(localStorage.getItem(LS_DAILY) || "{}");
          const t = todayKey();
          dlog[t] = (dlog[t] || 0) + delta;
          localStorage.setItem(LS_DAILY, JSON.stringify(dlog));
          console.debug("movie.addDailyProgress ->", {
            delta,
            newTotal: dlog[t],
            key: t,
          });
          // try to notify an opener window if present
          if (window.opener && window.opener.updateTodayChip)
            window.opener.updateTodayChip();
        } catch (e) {
          // ignore
        }
      }

      function computeCardDelay(word) {
        const base =
          Math.max(
            0.5,
            parseFloat(document.getElementById("interval").value) || 3
          ) * 1000;
        if (!word) return base;
        try {
          if ((word.original || "").length > LENGTH_THRESHOLDS.kanji)
            return Math.round(base * LENGTH_MULTIPLIER);
          if ((word.furigana || "").length > LENGTH_THRESHOLDS.furigana)
            return Math.round(base * LENGTH_MULTIPLIER);
          if ((word.meaning || "").length > LENGTH_THRESHOLDS.meaning)
            return Math.round(base * LENGTH_MULTIPLIER);
        } catch (e) {}
        return base;
      }

      function isLongWord(word) {
        if (!word) return false;
        try {
          if ((word.original || "").length > LENGTH_THRESHOLDS.kanji)
            return true;
          if ((word.furigana || "").length > LENGTH_THRESHOLDS.furigana)
            return true;
          if ((word.meaning || "").length > LENGTH_THRESHOLDS.meaning)
            return true;
        } catch (e) {}
        return false;
      }

      // getFamiliarity now uses cached progressMap; fallback to old arrays if needed
      function getFamiliarity(wordKey, wordOriginal) {
        if (progressMap && progressMap[wordKey]) return progressMap[wordKey];

        // fallback to old arrays stored as separate lists (imported older saves)
        try {
          const wellKnown = JSON.parse(
            localStorage.getItem("wellKnownWords") || "[]"
          );
          const known = JSON.parse(localStorage.getItem("knownWords") || "[]");
          const exposed = JSON.parse(
            localStorage.getItem("exposedWords") || "[]"
          );
          if (wellKnown.includes(wordOriginal)) return "well_known";
          if (known.includes(wordOriginal)) return "known";
          if (exposed.includes(wordOriginal)) return "explored";
        } catch (e) {
          // ignore
        }
        return "unknown";
      }

      function todayKey() {
        const d = new Date();
        return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(
          2,
          "0"
        )}-${String(d.getDate()).padStart(2, "0")}`;
      }

      // Track MovieFlow exposure using cached maps to avoid repeated JSON.parse
      function recordMovieflowExposure(wordKey) {
        movieflowMap[wordKey] = (movieflowMap[wordKey] || 0) + 1;
        localStorage.setItem(LS_MOVIEFLOW, JSON.stringify(movieflowMap));

        const today = todayKey();
        movieflowDailyMap[today] = (movieflowDailyMap[today] || 0) + 1;
        localStorage.setItem(
          LS_MOVIEFLOW_DAILY,
          JSON.stringify(movieflowDailyMap)
        );

        // Promote familiarity based on movie exposures (only upward)
        try {
          const exposures = movieflowMap[wordKey] || 0;
          let computedRank = 0; // 0 unknown, 1 explored, 2 known, 3 well_known
          if (exposures >= 50) computedRank = 3;
          else if (exposures >= 10) computedRank = 2;
          else if (exposures >= 1) computedRank = 1;

          const rankToFam = ["unknown", "explored", "known", "well_known"];

          // determine current rank from progressMap (or fallback)
          const curFam =
            progressMap[wordKey] || getFamiliarity(wordKey, "") || "unknown";
          const famToRank = {
            unknown: 0,
            explored: 1,
            known: 2,
            well_known: 3,
          };
          const curRank = famToRank[curFam] || 0;

          if (computedRank > curRank) {
            const newFam = rankToFam[computedRank];
            progressMap[wordKey] = newFam;
            localStorage.setItem(LS_PROGRESS, JSON.stringify(progressMap));

            // Update in-memory vocab familiarity if present
            for (let i = 0; i < vocab.length; i++) {
              if (vocab[i].key === wordKey) {
                vocab[i].familiarity = newFam;
                break;
              }
            }

            // Update highest-seen map and award daily progress points if this increases the highest rank
            try {
              const highMap = JSON.parse(
                localStorage.getItem(LS_HIGHEST) || "{}"
              );
              const famToRank = {
                unknown: 0,
                explored: 1,
                known: 2,
                well_known: 3,
              };
              const prevHighRank = famToRank[highMap[wordKey]] || 0;
              if (computedRank > prevHighRank) {
                highMap[wordKey] = newFam;
                localStorage.setItem(LS_HIGHEST, JSON.stringify(highMap));
                // award points equal to the rank increase
                addDailyProgress(computedRank - prevHighRank);
              }
            } catch (e) {
              console.error("Failed updating highest map from MovieFlow", e);
            }
          }
        } catch (e) {
          console.error("MovieFlow familiarity promotion failed", e);
        }

        // Update movieflowChip on index.html if it exists
        if (window.opener && window.opener.updateMovieflowChip) {
          window.opener.updateMovieflowChip();
        }
      }

      // Load CSV and apply initial filters using a single-pass parser
      showLoading();
      loadCaches();
      fetch("jlpt_vocab.csv")
        .then((res) => res.text())
        .then((text) => {
          try {
            // Parse entire CSV in one pass (returns rows array)
            const rows = parseCSV(text || "");
            vocab = [];
            const total = Math.max(rows.length - 1, 0);

            // Skip header row (assumed first row)
            for (let i = 1; i < rows.length; i++) {
              const parsed = rows[i] || [];
              const [Original, Furigana, English, JLPT] = parsed;
              const key = `${Original || ""}|${Furigana || ""}|${
                English || ""
              }`;
              vocab.push({
                original: Original || "",
                furigana: Furigana || "",
                meaning: English || "",
                jlpt: JLPT || "",
                level: 0,
                key: key,
                familiarity: getFamiliarity(key, Original || ""),
              });
            }

            // Build an ordered list (N5 -> N1) and assign numeric levels sequentially
            const jlptOrder = ["N5", "N4", "N3", "N2", "N1"];
            const ordered = [];
            jlptOrder.forEach((jl) => {
              for (let i = 0; i < vocab.length; i++) {
                if (vocab[i].jlpt === jl) ordered.push(vocab[i]);
              }
            });
            // append any words without JLPT at the end
            for (let i = 0; i < vocab.length; i++) {
              if (!vocab[i].jlpt || jlptOrder.indexOf(vocab[i].jlpt) === -1)
                ordered.push(vocab[i]);
            }

            // assign numeric levels: 100 words per level
            for (let i = 0; i < ordered.length; i++) {
              ordered[i].level = Math.floor(i / 100) + 1;
            }

            // Finalize
            // Adjust knownness options (remove empty ones) and update level option states
            try {
              adjustKnownnessOptions();
              updateLevelOptions();
            } catch (e) {}
                // Default level should be the first enabled option (not All Levels)
                const lvlSel = document.getElementById("levelSelect");
                if (lvlSel) {
                  const firstEnabled = Array.from(lvlSel.options).find((o) => !o.disabled && o.value !== "all");
                  if (firstEnabled) lvlSel.value = firstEnabled.value;
                }
            applyFilters();
          } catch (err) {
            console.error("MovieFlow load error", err);
            alert("‚ö†Ô∏è MovieFlow failed to load. See console for details.");
          } finally {
            hideLoading();
          }
        })
        .catch((err) => {
          console.error("Failed to fetch jlpt_vocab.csv", err);
          hideLoading();
          alert("‚ö†Ô∏è Could not load vocabulary file.");
        });

      function parseCSV(text) {
        const rows = [];
        let row = [];
        let cell = "";
        let inQuotes = false;

        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          const next = text[i + 1];

          if (ch === '"') {
            if (inQuotes && next === '"') {
              cell += '"';
              i++;
            } else inQuotes = !inQuotes;
          } else if (ch === "," && !inQuotes) {
            row.push(cell);
            cell = "";
          } else if ((ch === "\n" || ch === "\r") && !inQuotes) {
            if (ch === "\r" && next === "\n") i++;
            row.push(cell);
            if (row.join("").trim() !== "") rows.push(row);
            row = [];
            cell = "";
          } else {
            cell += ch;
          }
        }
        row.push(cell);
        if (row.join("").trim() !== "") rows.push(row);
        return rows;
      }

      // Disable level options that have no words for the current familiarity filter
      function updateLevelOptions() {
        const knownness = document.getElementById("knownness").value;
        const levelCounts = {}; // numeric level -> count
        const jlptCounts = { N1: 0, N2: 0, N3: 0, N4: 0, N5: 0 };

        vocab.forEach((w) => {
          const fam = getFamiliarityLevel(w);
          if (knownness !== "all" && fam !== knownness) return;
          if (w.level) levelCounts[w.level] = (levelCounts[w.level] || 0) + 1;
          if (w.jlpt && jlptCounts[w.jlpt] !== undefined) jlptCounts[w.jlpt]++;
        });

        const sel = document.getElementById("levelSelect");
        const opts = Array.from(sel.querySelectorAll("option"));

        // total items for current knownness (sum of numeric levels)
        const totalForKnownness =
          Object.values(levelCounts).reduce((a, b) => a + b, 0) ||
          Object.values(jlptCounts).reduce((a, b) => a + b, 0);

        opts.forEach((opt) => {
          const val = opt.value;
          if (val === "all") {
            opt.disabled = false;
            opt.hidden = false;
            opt.textContent = `All Levels (${totalForKnownness})`;
            return;
          }
          if (val.startsWith("jlpt-")) {
            const jl = val.substring(5);
            const count = jlptCounts[jl] || 0;
            const disabled = !(count > 0);
            opt.disabled = disabled;
            opt.hidden = disabled;
            opt.textContent = `JLPT ${jl} (${count})`;
          } else {
            const n = parseInt(val, 10);
            if (!isNaN(n)) {
              const count = levelCounts[n] || 0;
              const disabled = !(count > 0);
              opt.disabled = disabled;
              opt.hidden = disabled;
              opt.textContent = `Level ${n} (${count})`;
            }
          }
        });

        // If current selection became disabled, select first enabled option
        if (sel.selectedOptions[0] && sel.selectedOptions[0].disabled) {
          const firstEnabled = opts.find((o) => !o.disabled);
          if (firstEnabled) sel.value = firstEnabled.value;
          else sel.value = "all";
        }
      }

      // Remove empty knownness options and set sensible default on load
      function adjustKnownnessOptions() {
        const sel = document.getElementById("knownness");
        if (!sel) return;
        const order = ["unknown", "exposed", "known", "wellKnown"];
        let firstAvailable = null;

        order.forEach((val) => {
          const count = vocab.filter((w) => getFamiliarityLevel(w) === val).length;
          const opt = sel.querySelector(`option[value="${val}"]`);
          if (opt && count === 0) {
            opt.remove();
          } else if (opt && !firstAvailable) {
            firstAvailable = val;
          }
        });

        // If unknown exists, default to it; otherwise pick the first available
        if (sel.querySelector('option[value="unknown"]')) sel.value = "unknown";
        else if (firstAvailable) sel.value = firstAvailable;
        else sel.value = "all";
      }

      function getFamiliarityLevel(word) {
        if (word.familiarity === "well_known") return "wellKnown";
        if (word.familiarity === "known") return "known";
        if (word.familiarity === "explored") return "exposed";
        return "unknown";
      }

      function applyFilters() {
        const knownness = document.getElementById("knownness").value;
        const levelSelect = document.getElementById("levelSelect").value;

        filtered = vocab.filter((w) => {
          // Filter by familiarity/knownness
          if (knownness !== "all" && getFamiliarityLevel(w) !== knownness)
            return false;

          // Filter by level or JLPT
          if (levelSelect !== "all") {
            if (levelSelect.startsWith("jlpt-")) {
              // JLPT level
              const jlptLevel = levelSelect.substring(5); // "jlpt-N5" -> "N5"
              if (w.jlpt !== jlptLevel) return false;
            } else {
              // Numeric level (1-81)
              const numLevel = parseInt(levelSelect, 10);
              if (w.level !== numLevel) return false;
            }
          }

          return true;
        });

        index = 0;
        updateProgressIndicator();
      }

      function updateProgressIndicator() {
        const indicator = document.getElementById("progressIndicator");
        if (filtered.length === 0) {
          indicator.textContent = "No words";
        } else {
          indicator.textContent = `Word ${index + 1} / ${filtered.length}`;
        }
      }

      function showWord() {
        if (!filtered.length) {
          showSummary();
          return;
        }

        const w = filtered[index % filtered.length];
        document.getElementById("kanji").textContent = w.original;
        document.getElementById("furigana").textContent = w.furigana || "";
          // Generate romaji from furigana
          const romajiText = kanaToRomaji(w.furigana || "");
          const romajiDiv = document.getElementById("romaji");
          romajiDiv.textContent = romajiText;
          romajiDiv.classList.toggle("hidden", !document.getElementById("showRomaji").checked);
        document.getElementById("meaning").textContent = w.meaning;
      // Simple kana to romaji converter (Hepburn-ish, basic)
      function kanaToRomaji(input) {
        if (!input) return "";
        // Basic replacements for hiragana
        const table = {
          '„ÅÇ':'a','„ÅÑ':'i','„ÅÜ':'u','„Åà':'e','„Åä':'o',
          '„Åã':'ka','„Åç':'ki','„Åè':'ku','„Åë':'ke','„Åì':'ko',
          '„Åï':'sa','„Åó':'shi','„Åô':'su','„Åõ':'se','„Åù':'so',
          '„Åü':'ta','„Å°':'chi','„Å§':'tsu','„Å¶':'te','„Å®':'to',
          '„Å™':'na','„Å´':'ni','„Å¨':'nu','„Å≠':'ne','„ÅÆ':'no',
          '„ÅØ':'ha','„Å≤':'hi','„Åµ':'fu','„Å∏':'he','„Åª':'ho',
          '„Åæ':'ma','„Åø':'mi','„ÇÄ':'mu','„ÇÅ':'me','„ÇÇ':'mo',
          '„ÇÑ':'ya','„ÇÜ':'yu','„Çà':'yo',
          '„Çâ':'ra','„Çä':'ri','„Çã':'ru','„Çå':'re','„Çç':'ro',
          '„Çè':'wa','„Çí':'wo','„Çì':'n',
          '„Åå':'ga','„Åé':'gi','„Åê':'gu','„Åí':'ge','„Åî':'go',
          '„Åñ':'za','„Åò':'ji','„Åö':'zu','„Åú':'ze','„Åû':'zo',
          '„Å†':'da','„Å¢':'ji','„Å•':'zu','„Åß':'de','„Å©':'do',
          '„Å∞':'ba','„Å≥':'bi','„Å∂':'bu','„Åπ':'be','„Åº':'bo',
          '„Å±':'pa','„Å¥':'pi','„Å∑':'pu','„Å∫':'pe','„ÅΩ':'po',
          '„Åç„ÇÉ':'kya','„Åç„ÇÖ':'kyu','„Åç„Çá':'kyo',
          '„Åó„ÇÉ':'sha','„Åó„ÇÖ':'shu','„Åó„Çá':'sho',
          '„Å°„ÇÉ':'cha','„Å°„ÇÖ':'chu','„Å°„Çá':'cho',
          '„Å´„ÇÉ':'nya','„Å´„ÇÖ':'nyu','„Å´„Çá':'nyo',
          '„Å≤„ÇÉ':'hya','„Å≤„ÇÖ':'hyu','„Å≤„Çá':'hyo',
          '„Åø„ÇÉ':'mya','„Åø„ÇÖ':'myu','„Åø„Çá':'myo',
          '„Çä„ÇÉ':'rya','„Çä„ÇÖ':'ryu','„Çä„Çá':'ryo',
          '„Åé„ÇÉ':'gya','„Åé„ÇÖ':'gyu','„Åé„Çá':'gyo',
          '„Åò„ÇÉ':'ja','„Åò„ÇÖ':'ju','„Åò„Çá':'jo',
          '„Å≥„ÇÉ':'bya','„Å≥„ÇÖ':'byu','„Å≥„Çá':'byo',
          '„Å¥„ÇÉ':'pya','„Å¥„ÇÖ':'pyu','„Å¥„Çá':'pyo'
        };
        // Handle digraphs first
        let out = input;
        Object.keys(table).sort((a,b)=>b.length-a.length).forEach(kana=>{
          out = out.split(kana).join(table[kana]);
        });
        return out;
      }
      // Toggle romaji visibility
      document.getElementById("showRomaji").addEventListener("change", function() {
        const romajiDiv = document.getElementById("romaji");
        romajiDiv.classList.toggle("hidden", !this.checked);
      });

        // Record exposure
        recordMovieflowExposure(w.key);
        flowWordCount++;

        // compute delay for this card before advancing
        const delayForThis = computeCardDelay(w);

        // track extra-long cards (per display)
        if (isLongWord(w)) flowLongCount++;

        index++;
        updateProgressIndicator();

        // Check if we've reached the end
        if (index >= filtered.length) {
          clearTimeout(timer);
          // record true end time when final word displayed
          flowEndTime = Date.now();
          // Wait 3s so final word remains visible before showing summary
          timer = setTimeout(showSummary, 3000);
          return;
        }

        // schedule next card using per-card delay
        clearTimeout(timer);
        timer = setTimeout(showWord, delayForThis);
      }

      function showSummary() {
        const flowCard = document.getElementById("flowCard");
        const summaryScreen = document.getElementById("summaryScreen");

        flowCard.classList.add("hidden");
        summaryScreen.classList.remove("hidden");

        // Calculate stats ‚Äî use flowEndTime (when final word displayed) if available
        const endTs = flowEndTime || Date.now();
        const elapsed = Math.max(1, (endTs - flowStartTime) / 1000);
        const elapsedMinutes = elapsed / 60;
        const wpm = Math.round((flowWordCount / elapsedMinutes) * 10) / 10;
        const minutes = Math.floor(elapsed / 60);
        const seconds = Math.round(elapsed % 60);

        document.getElementById("summaryWords").textContent = flowWordCount;
        document.getElementById(
          "summaryTime"
        ).textContent = `${minutes}m ${seconds}s`;
        document.getElementById("summaryWPM").textContent = wpm;
        document.getElementById("summaryLong").textContent = flowLongCount;

        // Global project projections (concise): time until all words reach thresholds
        const TOTAL_WORDS = vocab.length || 8100;

        // Determine minutes per exposure from this session (time per shown word)
        if (!flowWordCount || !elapsedMinutes) {
          const na = "Not enough data";
          document.getElementById(
            "breakdownFamLabel"
          ).textContent = `${na} till all ${TOTAL_WORDS} are well known at this rate`;
          document.getElementById("breakdownFam").textContent = "";
          document.getElementById(
            "breakdownJLPTLabel"
          ).textContent = `${na} till all ${TOTAL_WORDS} are known at this rate`;
          document.getElementById("breakdownJLPT").textContent = "";
          document.getElementById(
            "breakdownJLPTSubLabel"
          ).textContent = `${na} till all ${TOTAL_WORDS} are explored at this rate`;
          document.getElementById("breakdownJLPTSub").textContent = "";
          document.getElementById("breakdownAll").textContent = "";
        } else {
          const minutesPerExposure = elapsedMinutes / flowWordCount; // minutes per exposure

          // Sum remaining exposures based on current familiarity and movieflow counts
          let remWell = 0; // exposures to bring all words to 50
          let remKnown = 0; // exposures to bring all words < known to 10
          let remExplored = 0; // exposures to bring unknown words to 1
          let remCountWell = 0; // words not well_known
          let remCountKnown = 0; // words with rank < known
          let remCountExplored = 0; // words that are unknown

          for (let i = 0; i < vocab.length; i++) {
            const w = vocab[i];
            const fam = progressMap[w.key] || getFamiliarity(w.key, w.original) || "unknown";
            const seen = movieflowMap && movieflowMap[w.key] ? parseInt(movieflowMap[w.key], 10) : 0;

            // For well known: any word not currently well_known needs (50 - seen)
            if (fam !== "well_known") {
              remWell += Math.max(0, 50 - seen);
              remCountWell++;
            }

            // For known: words with rank < known need (10 - seen)
            const rank = fam === "unknown" ? 0 : fam === "explored" ? 1 : fam === "known" ? 2 : 3;
            if (rank < 2) {
              remKnown += Math.max(0, 10 - seen);
              remCountKnown++;
            }

            // For explored: only words marked unknown need (1 - seen)
            if (fam === "unknown") {
              remExplored += Math.max(0, 1 - seen);
              remCountExplored++;
            }
          }

          const toHrsMins = (minutes) => {
            const total = Math.max(0, Math.round(minutes));
            const hrs = Math.floor(total / 60);
            const mins = total % 60;
            return `${hrs}h ${mins}m`;
          };

          const timeWell = toHrsMins(remWell * minutesPerExposure);
          const timeKnown = toHrsMins(remKnown * minutesPerExposure);
          const timeExplored = toHrsMins(remExplored * minutesPerExposure);

          document.getElementById("breakdownFamLabel").textContent = `${timeWell} till all words (${remCountWell} remaining) are well known at this rate`;
          document.getElementById("breakdownFam").textContent = "";
          document.getElementById("breakdownJLPTLabel").textContent = `${timeKnown} till all words (${remCountKnown} remaining) are known at this rate`;
          document.getElementById("breakdownJLPT").textContent = "";
          document.getElementById("breakdownJLPTSubLabel").textContent = `${timeExplored} till all words (${remCountExplored} unknown) are explored at this rate`;
          document.getElementById("breakdownJLPTSub").textContent = "";

          document.getElementById("breakdownAll").textContent = "";
        }
      }

      function selectNextRecommendedLevel() {
        // Find the next level (1-81) with the most unknown words
        let bestLevel = -1;
        let maxUnknownCount = 0;

        for (let level = 1; level <= 81; level++) {
          const unknownInLevel = vocab.filter(
            (w) => w.level === level && getFamiliarityLevel(w) === "unknown"
          ).length;

          if (unknownInLevel > maxUnknownCount) {
            maxUnknownCount = unknownInLevel;
            bestLevel = level;
          }
        }

        if (bestLevel === -1 || maxUnknownCount === 0) {
          alert(
            "üéâ No more unknown words! All vocabulary mastered. Return to Library."
          );
          document.getElementById("backToMenu").click();
          return;
        }

        // Auto-set filters to show next level with most unknowns
        document.getElementById("knownness").value = "all";
        document.getElementById("levelSelect").value = String(bestLevel);

        applyFilters();

        // Reset UI
        document.getElementById("flowCard").classList.remove("hidden");
        document.getElementById("summaryScreen").classList.add("hidden");

        // Play
        document.getElementById("play").click();
      }

      let paused = false;
      let wasPaused = false;
      document.getElementById("play").onclick = () => {
        // If timer is running, do nothing
        if (timer) return;
        // If just paused, resume from current index
        if (wasPaused && filtered.length > 0) {
          flowStartTime = flowStartTime || Date.now();
          wasPaused = false;
          showWord();
          return;
        }
        // Otherwise, (re)start session
        updateLevelOptions();
        applyFilters();
        if (filtered.length === 0) {
          alert("No words match your filters.");
          return;
        }
        clearTimeout(timer);
        flowStartTime = Date.now();
        flowWordCount = 0;
        flowLongCount = 0;
        flowEndTime = null;
        index = 0;
        showWord();
      };

      document.getElementById("pause").onclick = () => {
        if (timer) {
          clearTimeout(timer);
          timer = null;
          wasPaused = true;
        }
      };

      document.getElementById("playNext").onclick = selectNextRecommendedLevel;
      // When knownness changes, refresh available levels and filters
      document.getElementById("knownness").addEventListener("change", () => {
        updateLevelOptions();
        applyFilters();
      });

      document.getElementById("backToMenu").onclick = () => {
        document.getElementById("flowCard").classList.remove("hidden");
        document.getElementById("summaryScreen").classList.add("hidden");
        index = 0;
        updateProgressIndicator();
      };
    </script>
  </body>
</html>
